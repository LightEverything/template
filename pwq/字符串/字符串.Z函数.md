---
id: epiz14mcwn4aowx22xjsw3c
title: Z函数
desc: ''
updated: 1680512940169
created: 1680509614972
---

## 定义

$\text{Z}$ 函数定义和 [[字符串.前缀函数]] 的定义类似

后者是表示以 $i$ 为右端点的最长的与前缀相等的子串长度

而 $\text Z$ 函数 $Z[i]$ 定义为以 $i$ 为左端点的最长的与前缀相等的子串长度

## 求法

和前缀函数类似,我们考虑用前面的状态来得出后面的状态

假设已经求出了 $Z[i]$, 现在需要求 $Z[i+1]$

如果 $Z[i] \neq 0$, 由定义可得, $s[0,Z[i]-1] = s[i,i+Z[i]-1]$,那么就有 $s[1,Z[i]-1] = s[i+1,i+Z[i]-1]$, 若 $Z[1] <= i+Z[i]-1 - (i+1) + 1$, 则 $Z[i+1]=Z[1]$

若 $Z[1] > i+Z[i]-1-(i+1)+1$,这只能说明 $s[i+1,i+Z[i]-1]$ 是 $\text s$ 的一个前缀,但不能说明后面的部分不是 $\text s$ 的前缀,故考虑暴力向后查找

如果 $Z[i] = 0$, 这样就不方便按照上面的方法来计算, 我们可以考虑记录 $[1,i]$ 中满足 $i'+Z[i']-1$ 最大的 $i'$, 如果 $i' + Z[i'] - 1 < i+1$,则考虑暴力向后查找,否则可以用上面 $Z[i] \neq 0$ 的方法解决

综合起来,我们只需要记录一个区间 $[l,r]$ 满足 $s[l,r] = s[0,r-l+1]$, 然后不断的更新左右端点,因为右端点是不断向右推进的, 故复杂度为 $\text O (\text n)$

```cpp
int Z[N];
inline void Z_Algorithm(string s) {
    Z[0] = 0;
    int n = s.length();
    for (int i = 1, l = 0, r = 0; i < n; ++i) { // 当前区间满足该区间一定和原字符串的一个前缀相等
        if (i <= r && Z[i - l] < r - i + 1) {   // 如果i在当前维护的区间,则说明s[i-l,r-l] = s[i,r],此时如果Z[i-l]<r-l+1,则Z[i]=Z[i-l]
            Z[i] = Z[i - l];
        } else {
            // 否则考虑暴力拓展
            if (r < i) // 如果r<i则从s[0]开始比较
                Z[i] = 0;
            else // 否则从s[r-i+1]开始比较
                Z[i] = r - i + 1;
            while (i + Z[i] < n && s[Z[i]] == s[i + Z[i]])
                ++Z[i];
        }
        if (i + Z[i] - 1 > r) { // 判断是否需要更新当前区间
            l = i;
            r = i + Z[i] - 1;
        }
        // cout << Z[i] << " ";
    }
    // 根据题目要求确定 Z[0]
    // 部分题目Z[0]=0,部分题目Z[0]=n
    Z[0] = n;
    // cout << endl;
}
```

## 应用

参考 [[字符串.前缀函数]]
